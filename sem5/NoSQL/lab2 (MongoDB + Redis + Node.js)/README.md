# Варіант 14: Система управління навчальними курсами.

## Опис завдання
Це розширений варіант першої лабораторної роботи. До звичайної реляційної бази (PostgreSQL) додано дві NoSQL бази, щоб пришвидшити роботу системи:
* MongoDB (Document store): щоб зберігати складну структуру курсу одним шматком, а не збирати її по частинах.
* Redis (Key-Value store): для кешування часто запитуваних даних (каталог курсів).

## Використані технології
* Node.js, PostgreSQL (з лаб.1)
* MongoDB, Redis
* Docker

## Обгрунтування вибору NoSQL
### Проблема швидкості (MongoDB)
У реляційній моделі курс розбитий на 3 таблиці: Courses -> Sections -> Lessons. Щоб відобразити студенту повну програму курсу треба виконати 2 важких JOIN (або 3 окремих запити) і програмно, або засобами SQL, склеїти це в ієрархічний JSON. Коли користувачів багато, це створює зайве навантаження на процесор БД.

Рішення (MongoDB): використати документо-орієнтовану базу для зберігання агрегованого вигляду курсу. Тобто зберігаємо весь курс (з усіма секціями та уроками) як один великий JSON-документ.
Перевага: Отримання повної програми виконується за O(1) (пошук одного документа за індексом) за одну дію, без необхідності обчислень на стороні БД.

### Проблема частого доступу (Redis)
Сторінку зі списком курсів відкривають постійно. Дані там змінюються рідко (наприклад, раз на тиждень), але читаються щосекунди. Постійно смикати основну базу (Postgres) заради одних і тих самих даних — неефективно.

Рішення (Redis): використати Key-Value сховище в оперативній пам'яті. Якщо дані є в кеші — беремо їх звідти. Якщо немає — беремо з бази і кладемо в кеш на 60 секунд.

## Результати benchmark MongoDB
Тестування проводилося на курсі, який містить 2000 вкладених уроків. Щоб отримати точний результат і виключити випадкові затримки, робимо 1000 запитів підряд.

Сценарій тесту:
SQL: запит з використанням `json_agg` та `json_build_object` для побудови вкладеного JSON на стороні бази (імітація реального бекенду).
NoSQL: нативний findOne драйвера MongoDB.

Отримані результати:
SQL (Complex Query): ~16.5 sec (для 1000 запитів)
NoSQL (Native Find): ~2.3 sec (для 1000 запитів)

Висновок: MongoDB виявилася швидшою у ~7 разів. Це зумовлено тим, що PostgreSQL витрачає час процесора на JOIN та серіалізацію JSON, тоді як MongoDB просто зчитує готовий документ.

## Реалізація Redis
Реалізовано в `src/repositories/CourseRepository.js`. 
Логіка роботи методу `getPublishedCourses`:
Перевірити наявність ключа `courses:published_list` у Redis.
Якщо є — повернути JSON (час < 5ms).
Якщо немає — зробити SELECT з PostgreSQL, зберегти в Redis з TTL 60с і повернути дані (час ~50ms).

## Запуск
Потребує встановлених Node.js та Docker.
### Підготовка оточення
```bash
# 1) Запуск БД (Postgres, Mongo, Redis)
docker-compose up -d

# 2) Встановлення залежностей
npm install

# 3) Ініціалізація SQL схеми та даних
node init_db.js
node finish_setup.js
```

### Запуск тестів
Перший скрипт генерує "важкий" курс (100 секцій, 2000 уроків), мігрує його в Mongo і порівнює швидкість читання:
```bash
node benchmark.js
```

Другий скрипт демонструє роботу кешу: перший запит йде в БД, другий - миттєво з Redis:
```bash
node redis_demo.js
```